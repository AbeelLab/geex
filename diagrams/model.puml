@startuml
class DrawableNode {
    currentIncoming : int
    translateX : double
    translateY : double

    +incrementIncoming() : int
}

package model {
abstract class Parser<T> {
    readerList : BufferedReader[]

    +setReader(files : File...) : Parser<T>
    +parse() : T
    + {abstract} parse(file : BufferedReader...) : T
}

package graph {
    class BaseCounter<Character, MutableInt> extends java.util.HashMap {
        {static} df : DecimalFormat
        # baseSize : int

        +getPercentage(c : char)
        +getPercentageString(c : char)
    }
    abstract class DefaultGraph<T, DefaultWeightedEdge> extends org.jgrapht.graph.DefaultDirectedWeightedGraph {
        +getFirstNodes() : List<T>
        +getTargets(node : T) : List<T>
        +getSources(node : T) : List<T>
        +replace(oldNode : T, newNode : T)
    }
    abstract class DefaultNode {
           sources : Set<String>
           content : String

           +getLabel(mainController : MainController, graphController : DefaultGraphController, drawableNode : DrawableNode) : DefaultLabel
    }
    class graph.Node extends DrawableNode {
        # id : int
        # sources : Set<String>
        # refStartPosition : int
        # refEndPosition : int
        # content : String
        # baseCounter : BaseCounter
    }
    class graph.NodeParser {
        #getNodeId(sc : Scanner) : int
        +getNode(sc : Scanner) : Node
    }

    class Graph extends StackGraph
    class GraphMap<String, Graph> extends java.util.concurrent.ConcurrentHashMap {
        +flat(sources : Set<String>) : Graph
        -getGraphList(sources : Set<String>) : List<Graph>
        -getGraph(source : String) : Graph
        +addVertex(node : Node)
        +addEdge(source : Node, target : Node)
        +filter()
    }
    class GraphNode extends DefaultNode {
        nodes : Set<DefaultNode>
    }
    class GraphParser<GraphMap> extends Parser {
        -parseNodes(nodeFile : File, graph : Graph) : List<Node>
        -parseEdges(edgeFile : File, graph : Graph, nodeList : List<Node>)
    }
    class SinglePointGraph extends StackGraph {
        singlePart : Set<DefaultNode>
        single : Map<DefaultNode, DefaultNode>
        graph : StackGraph

        -markSingle()
        -filterSingle()
        -replaceSingle()
    }

    abstract class StackGraph<DefaultNode> extends DefaultGraph {
        #setGraph(stackGraph : StackGraph)
        +createSubGraph(nodes : Set<DefaultNode>) : Graph
    }

    'Relations

    GraphParser ..> GraphMap : << create >>
    GraphMap --> Graph : << contains >>
    GraphParser ..> graph.NodeParser

    Graph --> graph.Node : << contains >>

    graph.NodeParser ..> graph.Node : << create >>
    graph.Node *-- BaseCounter

    StackGraph --> DefaultNode : << contains >>

    DefaultNode --> DefaultNode : << contains >>
}


package newick {
    class newick.Node extends DrawableNode {
        - name : String
        - weight : double
        - children : List<Node>
        - parent : Node
        - selection : Selection
    }
    class newick.NodeParser {
        +getNode(node : TreeNode) : Node
    }
    class Newick<Node, DefaultEdge> extends org.jgrapht.graph.DefaultDirectedGraph {
        root : newick.Node

        +getFirstNode() : Node
        +toString(node : Node, level : int)
    }
    class NewickParser<Tree> extends Parser {
        +getOffspring(node : TreeNode, parent : Node, tree : Tree) : int
        +createNode(child : TreeNode, parent : Node, row : int) : Node
        +addDummy(parent : Node, n : Node, tree : Tree
    }

    package selection {
        interface Selection {
            useSources() : boolean
            isAny() : boolean

            toggle() : Selection
            merge(selection : Selection) : Selection
            styleClass() : String
        }

        class All implements Selection
        class None implements Selection
        class Partial implements Selection
    }

    NewickParser ..> Newick : << create >>
    NewickParser ..> newick.NodeParser
    newick.NodeParser ..> newick.Node : << create >>

    Newick --> newick.Node : << contains >>
}

package annotation {
    class Annotation {
        id : int
        name : String
        strand : boolean
        start : int
        end : int
        proteinName : String

        +equalsLoose(other : Annotation) : boolean
    }
    class AnnotationMap<String, Annotation> extends java.util.HashMap
    class AnnotationParser<AnnotationMap> extends Parser {
        +getAnnotation(splitLine : String) : Annotation
    }

    'Relations

    AnnotationParser ..> AnnotationMap : << create >>
    AnnotationMap "1" --> "*" Annotation : << contains >>
}

package resistance {
    class Resistance {
        geneName : String
        typeOfMutation : String
        change : String
        genomePosition : int
    }
    class ResistanceMap<Integer, Resistance> extends java.util.HashMap
    class ResistanceParser<ResistanceMap> extends Parser {
        +getResistance(splitLine : String[]) : Resistance
    }

    ResistanceParser ..> ResistanceMap : << create >>
    ResistanceMap "1" --> "*" Resistance : << contains >>
}
}
@enduml
